#include <stdio.h>
#include <stdlib.h>
//#include <math.h>
#include "jrb.h"
#include "dllist.h"

#define MAX_SLOTS 1000
typedef struct {
    JRB edges;
    JRB vertices;
} GraphType;

GraphType create_graph();
void add_vertex(GraphType graph, int id, char* name);
char *get_vertex(GraphType graph, int id);
void add_edge(GraphType graph, int v1, int v2);
int has_edge(GraphType graph, int v1, int v2);
int in_deg(GraphType graph, int v, int* output);
int out_deg(GraphType graph, int v, int* output);
int DAG(GraphType graph);
//int adjacent(GraphType graph, int v1, int v2);
//int get_neighbors(GraphType graph, int vertex, int* output);//Return the number of neighbors
void drop_graph(GraphType graph);

GraphType create_graph() {
    GraphType g;
    g.edges = make_jrb();
    g.vertices = make_jrb();
    return g;
}

void add_vertex(GraphType g, int id, char* name) {
    JRB node, tree;
    
    if(!(node = jrb_find_int(g.vertices, id))) {
        jrb_insert_int(g.vertices, id, new_jval_s(name));
    }
}
char *get_vertex(GraphType g, int id) {
    JRB node = jrb_find_int(g.vertices, id);
    if (node==NULL) 
        return NULL;
    else                
        return jval_s(node->val);  
}

void add_edge(GraphType g, int v1, int v2) {
    JRB node, tree;
    if(node = jrb_find_int(g.edges, v1)) {
        tree = (JRB) jval_v(node->val);
        jrb_insert_int(tree, v2, new_jval_i(1));
    }
    else {
        tree = make_jrb();
        jrb_insert_int(g.edges, v1, new_jval_v(tree));
        jrb_insert_int(tree, v2, new_jval_i(1));
    }
}

int has_edge(GraphType g, int v1, int v2) {
    JRB node, tree;
    if(node = jrb_find_int(g.edges, v1)) {
        tree = (JRB) jval_v(node->val);
        jrb_traverse(node, tree)
            if(v2 == jval_i(node->key)) return 1;
    }
    return 0;
}

int in_deg(GraphType g, int v, int* o) {
    JRB node, tree, temp;
    int total = 0;
    jrb_traverse(node, g.edges){
        tree = jval_v(node->val);
        temp = NULL;
        temp = jrb_find_int(tree, v);
        if (temp != NULL)
            o[total++] = jval_i(node->key);
    }
    return total;
}

int out_deg(GraphType g, int v, int* o) {
    JRB node, tree;
    node = jrb_find_int(g.edges, v);
    if(node == NULL) return 0;
    tree = (JRB) jval_v(node->val);
    int total = 0;
    jrb_traverse(node, tree)
        o[total++] = jval_i(node->key);
    return total;
}

void drop_graph(GraphType g) {
    JRB node;
    jrb_traverse(node, g.edges)
        jrb_free_tree( jval_v(node->val) );
    jrb_free_tree(g.edges);
    jrb_free_tree(g.vertices);
}

int* BFS(GraphType graph, int start, int stop, void (*func)(int))
{
   int* visited = calloc(1000, sizeof(int));
   int n, output[100], i, u, v;
   Dllist node, queue;
   
   queue = new_dllist();
   dll_append(queue, new_jval_i(start));

   while ( !dll_empty(queue) )
   {
      node = dll_first(queue);
      u = jval_i(node->val);
      dll_delete_node(node);
      if (!visited[u]) 
      {
          func(u);
          visited[u] = 1;
          if ( u == stop ) return visited;           
          n = out_deg(graph, u, output);
          for (i=0; i<n; i++)
          {
              v = output[i];
              if (!visited[v])
                 dll_append(queue, new_jval_i(v));
          }
      }
   }
   return visited;                            
}

int* DFS(GraphType graph, int start, int stop, void (*func)(int))
{
   int* visited = calloc(1000, sizeof(int));
   int n, output[100], i, u, v;
   Dllist node, stack;
   
   stack = new_dllist();
   dll_append(stack, new_jval_i(start));

   while ( !dll_empty(stack) )
   {
      node = dll_last(stack);
      u = jval_i(node->val);
      dll_delete_node(node);
      if (!visited[u]) 
      {
          func(u);
          visited[u] = 1;
          if ( u == stop ) return visited;           
          n = out_deg(graph, u, output);
          for (i=0; i<n; i++)
          {
              v = output[i];
              if (!visited[v])
                 dll_append(stack, new_jval_i(v));
          }
      }
   }
   return visited;                            
}

void print_vertex(int v) {printf("%4d", v);}

/*
int DAG(GraphType g) {
    int* visited = BFS(g, 0, -1, print_vertex);
    JRB node, tree = g.vertices;
    jrb_traverse(node, tree)
        if(visited[jval_i(node->key)] == 0) return 0;
}
*/

int* in_deg_arr(GraphType g) {
    int* indegree = calloc(1000, sizeof(int));
    int out[1000];
    JRB node, tree = g.vertices;
    jrb_traverse(node, tree) {
        int key = jval_i(node->key);
        indegree[key] = in_deg(g, key, out);
    }
    return indegree;
}

Dllist topological_sort(GraphType g, int* out, int* n) {
    Dllist node, queue;
    JRB vertex;
    queue = new_dllist();
    *n = 0;
    int o[1000];
    int* indegree = in_deg_arr(g);
    jrb_traverse(vertex, g.vertices) {
        if(indegree[jval_i(vertex->key)] == 0)
            dll_append(queue, vertex->key);
    }
    while ( !dll_empty(queue) )
    {
      node = dll_first(queue);
      int v = jval_i(node->val);
      dll_delete_node(node);
      out[(*n)++] = v;
      int n = out_deg(g, v, o);
      for(int i = 0; i < n; ++i) {
          indegree[o[i]]--;
          if(indegree[o[i]] == 0)
            dll_append(queue, new_jval_i(o[i]));
      }
   }
}

int DAG(GraphType graph)
{
   int visited[1000];
   int n, output[100], i, u, v, start;
   Dllist node, stack;
   JRB vertex;
   
   jrb_traverse(vertex, graph.vertices)
   {
       int* visited = calloc(1000, sizeof(int));;

       start = jval_i(vertex->key);              
       stack = new_dllist();
       dll_append(stack, new_jval_i(start));
    
       while ( !dll_empty(stack) )
       {
          node = dll_last(stack);
          u = jval_i(node->val);
          dll_delete_node(node);
          if (!visited[u])
          {
              visited[u] = 1;
              n = out_deg(graph, u, output);
              for (i=0; i<n; i++)
              {
                  v = output[i];
                  if ( v == start ) // cycle detected 
                     return 0;
                  if (!visited[v])    
                     dll_append(stack, new_jval_i(v));
              }
          }           
       }
   }
   return 1; // no cycle    
}


int main() {
    GraphType g = create_graph();
    add_vertex(g, 0, "CS102"); add_vertex(g, 1, "CS140");
    add_vertex(g, 2, "CS160"); add_vertex(g, 3, "CS302");
    add_vertex(g, 4, "CS311"); add_vertex(g, 5, "MATH300");
    add_edge(g, 0, 1); add_edge(g, 0, 2);
    add_edge(g, 1, 3); add_edge(g, 5, 4); add_edge(g, 3, 4);
    if (!DAG(g)) {
        printf("Can not make topological sort\n");
        return 1; }
    int output[1000];
    int n;
    topological_sort(g, output, &n);
    printf("The topological order:\n");
    for (int i=0; i<n; i++)
        printf("%s\n", get_vertex(g, output[i]));
}